---
title: "4.1. 数据流量控制"
anchor: "4.1_Data_Flow_Control"
weight: 410
rank: "h2"
---

QUIC使用一个基于限制的流量控制模型，接收者给出其准备在给定流或整个连接上准备接收的总字节数的上限。
这使得QUIC中存在两层数据流量控制：
- 流的流量控制：通过限制每条流可以发送的数据量，防止单条流耗尽一条连接的全部接收缓冲区；
- 连接流量控制：通过限制所有流经由**流帧**可以发送的数据量，防止发送方超过连接接收方的缓冲区容量。

发送方发送数据{{< req_level MUST_NOT >}}能超过上述任何一个限制。

接收方在握手过程中（[第7.4章]()）通过传输参数为所有流设置初始的流接收缓存区上限。随后，接收方发送**最大流数据帧**（[第19.10章]()）或**最大数据帧**（[第19.9章]()）以告知对方提高流接收缓存区上限。

接收方可以通过发送一个含相关流ID的**最大流数据帧**告知对方提高流接收缓存区上限。
**最大流数据帧**表示流的最大绝对字节偏移量。
接收方可以根据当前流消耗数据的偏移量确定后续发出的流量控制的偏移量。

接收方可以通过发送一个**最大数据帧**告知对方提高连接的接收缓存区上限，亦即所有流绝对字节偏移量之和的上限。
接收方维护一个在所有流上累计接收数据的总字节数，用以检查是否超过了连接或流流量控制上限。
接收方可以基于在所有流上消耗数据总字节数确定后续发出的最大数据偏移量。

接收方发布连接或流的流量控制上限若低于之前的上限，这不是错误，只是这个更低的上限不会生效而已。

如果发送方违反了推荐的连接或流的流量控制上限，接收方{{< req_level MUST >}}以FLOW_CONTROL_ERROR类型错误关闭连接，更多错误处理相关细节详见[第11章]()。

发送方{{< req_level MUST >}}忽略任何不会提高流量控制上限的**最大流数据帧**或**最大数据帧**。

如果发送方发送数据达到了流量控制上限，其将不能再发送新数据，且应认为其被阻塞住了。
发送方{{< req_level SHOULD >}}发送一个**流数据阻塞帧**或**数据阻塞帧**来告知接收方其有数据要写出但是被流量控制所阻塞。
如果发送方被阻塞的时间超过空等超时时间（[第10.1章]()），接收方可以关闭连接，即便发送方有可传输的数据。
为了保持连接不被关闭，在没有可引发ACK的数据包处于传输中时，被流量控制限制所阻塞的发送方{{< req_level SHOULD >}}定期发送一个**流数据阻塞帧**或**数据阻塞帧**。
