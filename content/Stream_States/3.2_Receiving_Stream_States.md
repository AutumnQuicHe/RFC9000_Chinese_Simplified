---
title: "3.2. 接收流状态"
anchor: "3.2_Receiving_Stream_States"
weight: 320
rank: "h2"
---

[图3](#Figure_3_States_for_Receiving_Parts_of_Streams)展示了通过流从对端接收数据的状态。
流的接收部分只会反映对端流发送部分的一些状态。
流的接收部分不能追踪发送部分那些不可见的状态，例如“就绪”状态。
相反，流的接收部分追踪向应用层传递的数据，其中一些数据对发送端不可见。

{{< block_img
    indx="Figure_3_States_for_Receiving_Parts_of_Streams"
    title="图3：流数据接收部分状态"
    type="svg"
    src="Figure_3_States_for_Receiving_Parts_of_Streams.svg" >}}

由对端发起的流（客户端发起的流类型是1和3，服务端发起的是0和2）的接收部分在收到该流的第一个**流帧**、**流阻塞帧**或**流重置帧**时创建。
对于由对端创建的双向流，发送部分收到**最大流数据帧**或**停止发送帧**时也会创建该流的接收部分。
流的接收部分的初始状态是“发送”状态。

由本端发起的双向流（客户端发起的流类型是0，服务端发起的是1），当其发送部分进入“就绪”状态时，其接收部分进入“接收”状态。

终端在收到**最大流数据帧**或**停止发送帧**后打开一条双向流。
接收到一条未开启的流的**最大流数据帧**意味着对端已经开启了该流，并开始支持流量控制信用。
而接收到一条未开启流的**停止发送帧**意味着对端不会再从该流接收数据。
无论这两种帧的哪一种都可能先于**流帧**或**流阻塞帧**到达本端，原因是包丢失或乱序。

在一条流创建前，所有数值小于该流ID的同类型流都{{< req_level MUST >}}被创建。
这样能确保双端流的创建次序保持一致。

在“接收”状态，终端接收**流帧**和**流阻塞帧**。
传入数据将被缓存，并可以按照正确顺序重组以便递给应用层。
随着应用层不断消耗数据，缓冲区重新空出来，终端发送**最大流数据帧**告知对端可以发送更多数据。

当收到一个带FIN置位的**流帧**时，数据的最终大小确定下来，详见[第4.5章]()。
流的接收部分随后转到“数据量确认”状态。
在此状态，终端不再需要发送**最大流数据帧**，只需要接收重传数据即可。


Once all data for the stream has been received, the receiving part enters the "Data Recvd" state. This might happen as a result of receiving the same STREAM frame that causes the transition to "Size Known". After all data has been received, any STREAM or STREAM_DATA_BLOCKED frames for the stream can be discarded.

The "Data Recvd" state persists until stream data has been delivered to the application. Once stream data has been delivered, the stream enters the "Data Read" state, which is a terminal state.

Receiving a RESET_STREAM frame in the "Recv" or "Size Known" state causes the stream to enter the "Reset Recvd" state. This might cause the delivery of stream data to the application to be interrupted.

It is possible that all stream data has already been received when a RESET_STREAM is received (that is, in the "Data Recvd" state). Similarly, it is possible for remaining stream data to arrive after receiving a RESET_STREAM frame (the "Reset Recvd" state). An implementation is free to manage this situation as it chooses.

Sending a RESET_STREAM means that an endpoint cannot guarantee delivery of stream data; however, there is no requirement that stream data not be delivered if a RESET_STREAM is received. An implementation MAY interrupt delivery of stream data, discard any data that was not consumed, and signal the receipt of the RESET_STREAM. A RESET_STREAM signal might be suppressed or withheld if stream data is completely received and is buffered to be read by the application. If the RESET_STREAM is suppressed, the receiving part of the stream remains in "Data Recvd".

Once the application receives the signal indicating that the stream was reset, the receiving part of the stream transitions to the "Reset Read" state, which is a terminal state.