---
title: "3.2. 接收流状态"
anchor: "3.2_Receiving_Stream_States"
weight: 320
rank: "h2"
---

[图3](#Figure_3_States_for_Receiving_Parts_of_Streams)展示了通过流从对端接收数据的状态。
流的接收部分只会反映对端流发送部分的一些状态。
流的接收部分不能追踪发送部分那些不可见的状态，例如“就绪”状态。
相反，流的接收部分追踪向应用层传递的数据，其中一些数据对发送端不可见。

{{< block_img
    indx="Figure_3_States_for_Receiving_Parts_of_Streams"
    title="图3：流数据接收部分状态"
    src="/RFC9000_Chinese_Simplified/images/Figure_3_States_for_Receiving_Parts_of_Streams.svg" >}}

由对端发起的流（客户端发起的流类型是1和3，服务端发起的是0和2）的接收部分在收到该流的第一个**流帧**、**流阻塞帧**或**流重置帧**时创建。
对于由对端创建的双向流，发送部分收到**最大流数据量帧**或**停止发送帧**时也会创建该流的接收部分。
流的接收部分的初始状态是“接收”状态。

由本端发起的双向流（客户端发起的流类型是0，服务端发起的是1），当其发送部分进入“就绪”状态时，其接收部分进入“接收”状态。

终端在收到**最大流数据量帧**或**停止发送帧**后打开一条双向流。
接收到一条未开启的流的**最大流数据量帧**意味着对端已经开启了该流，并开始支持流量控制额度。
而接收到一条未开启流的**停止发送帧**意味着对端不会再从该流接收数据。
无论这两种帧的哪一种都可能先于**流帧**或**流阻塞帧**到达本端，原因是包丢失或乱序。

在一条流创建前，所有数值小于该流ID的同类型流都{{< req_level MUST >}}被创建。
这样能确保双端流的创建次序保持一致。

在“接收”状态，终端接收**流帧**和**流阻塞帧**。
传入数据将被缓存，并可以按照正确顺序重组以便递给应用层。
随着应用层不断消耗数据，缓冲区重新空出来，终端发送**最大流数据量帧**告知对端可以发送更多数据。

当收到一个带FIN置位的**流帧**时，数据的最终大小确定下来，详见[第4.5章](#4.5_Stream_Final_Size)。
流的接收部分随后转到“数据量确认”状态。
在此状态，终端不再需要发送**最大流数据量帧**，只需要接收重传数据即可。

一旦收完了一条流的所有数据，流的接收部分转入“接收完成”状态。
这可能发生在收到导致转入“数据量确认”状态的同一个**流帧**后。
在所有数据都收完后，可以丢弃该流的任何**流帧**或**流阻塞帧**。

{{% block note %}}
**秋航注**：意思是说，在收到**流帧**后，接收方可能转入“接收量确认”状态；紧接着，状态再次流转到“接收完成”状态。
中间这句原译为：
> 在接收到导致状态转换到“接收量确认”的**流帧**后，可能同时导致转入“接收完成”状态。
{{% /block %}}

“接收完成”状态会一直持续直到数据全部传递到应用层。
一旦流数据传递完成，即转到“读取完成”状态，这是一个最终状态。

如果在“接收”或“数据量确认”状态收到一个**流重置帧**，将导致流转到“重置接收”状态。
这可能打断流数据传递到应用层。

**流重置帧**也有可能在所有流数据都收完后才收到（即在“接收完成”阶段）。
同样地，也可能在收完**流重置帧**后收到了剩下的流数据（即在“重置接收”状态）。
在QUIC的具体实现上，可以自由选择如何处理这两种情况。

发送**流重置帧**意味着终端不能保证流数据的传输。
然而，并没有要求在收到**流重置帧**后不传输流数据。
QUIC实现{{< req_level MAY >}}打断流数据的传输，丢弃任何没有被消耗的数据，并通知对端收到了**流重置帧**。
如果流数据完成了接收并被缓存起来以供应用层读取，此时收到**流重置帧**信号，则该信号可能被抑制或扣留。
如果**流重置帧**被抑制，流的接收部分仍然维持在“接收完成”状态。

一旦应用层收到流被重置的信号，流的接收部分转到“重置读取”阶段，这是一个最终状态。