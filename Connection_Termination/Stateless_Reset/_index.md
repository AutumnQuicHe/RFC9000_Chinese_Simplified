---
title: "10.3 无状态重置"
anchor: "10.3_Stateless_Reset"
weight: 1030
rank: "h2"
---

如果终端无法访问连接的状态数据，那么无状态重置将是其最后手段。崩溃或中断可能造成对端持续向一个没有正常地维持连接的终端发送数据。终端{{< req_level MAY >}}在接收到一个它无法关联到某个活跃连接的数据包时发送无状态重置作为响应。

无状态重置不适合用来表明在活跃连接中出现的错误。想要传达致命的连接错误这一消息的终端在有能力的情况下{{< req_level MUST >}}使用**连接关闭帧**。

为了支持无状态重置，终端会签发一个无状态重置令牌，它是一个难以猜测的16字节长的值。如果对端后续收到了无状态重置，也就是一个以那个无状态重置令牌结尾的UDP数据报，那么对端将立即结束这条连接。

每个无状态重置令牌都是特定于某个连接ID的。终端签发无状态重置令牌时，将它的值包含在**新连接ID帧**的无状态重置令牌字段中。服务器还可以在握手期间签发传输参数`stateless_reset_token`（无状态重置令牌），它会被应用到服务器在握手期间选择的连接ID上。这些信息交换是受到加密保护的，所以只有客户端和服务器知道它们的值。注意，客户端不能使用传输参数`stateless_reset_token`，因为它们的传输参数没有可信度保护。

当令牌关联的连接ID被**停用连接ID帧**（详见[第19.16章](#19.16_RETIRE_CONNECTION_ID_Frames)）停用时，令牌将失效。

如果终端接收到了它无法处理的数据包，那么它会以这种形式发送一个数据包：

{{% block_ref
indx="Figure_10_Stateless_Reset"
title="图10：无状态重置" %}}

```
无状态重置 {
  固定比特位 (2) = 1,
  不可预测的比特位 (38..),
  无状态重置令牌 (128),
}
```

{{% /block_ref %}}

这种设计确保无状态重置——尽可能地——无法和常规的短包头数据包区分。

无状态重置使用从数据包头部的最前面两个比特位开始的一整个UDP数据报。首个字节的剩余部分和在它之后任意数量的字节都{{< req_level SHOULD >}}被设置为无法分辨是不是随机的值。数据报的最后16个字节包含了无状态重置令牌。

对于不是意图的接收方的实体来说，无状态重置看起来就是一个短包头数据包。为了让无状态重置表现得像一个合法QUIC数据包，不可预测的比特位应该使用至少38比特的数据（或者说5字节并去掉两个固定比特位）。

如果接收方要求使用连接ID，那么那作为结果的至少21个字节并不保证无状态重置很难与其他数据包区分。为了做到这一点，终端{{< req_level SHOULD >}}确保所有它发送的数据包都比它要求对端在数据包中包含的最小的连接ID的长度要长至少22字节，不够就加**填充帧**。这么做能确保所有对端发出的无状态重置都无法和发送给当前终端的合法数据包区分。在发送无状态重置来响应一个不超过43字节的数据包时，终端{{< req_level SHOULD >}}发送一个比它要响应的那个数据包要短一个字节的无状态重置。

以上数值假设了无状态重置令牌和数据包保护AEAD的最小扩充量具有相同长度。如果终端协商了具有更大的最小扩充量的数据包保护方案，那么就需要额外的不可预测字节。

终端发送的无状态重置尺寸{{< req_level MUST_NOT >}}是它接收到的数据包的三倍或更大，以免被用于放大攻击。[第10.3.3章](#10.3.3_Looping)描述了无状态重置尺寸的额外限制。

终端{{< req_level MUST >}}丢弃因过小而不合法的QUIC数据包。举个例子，在使用《[QUIC-TLS](/RFC9001_Chinese_Simplified)》中定义的AEAD函数组时，小于21字节的短包头数据包永远不可能合法。

终端{{< req_level MUST >}}将无状态重置以短包头数据包的格式发送。然而，终端{{< req_level MUST >}}将任何以有效无状态重置令牌结尾的数据包视作无状态重置，因为其他QUIC版本可能允许使用长包头。

终端{{< req_level MAY >}}在响应长包头数据包时发送无状态重置。在无状态重置令牌在对端处可用前发送无状态重置是没有效果的。在本QUIC版本中，只能在连接建立期间使用长包头数据包。由于无状态重置令牌只有在连接建立完成或临近完成时才可用，忽略长包头数据包的效果和发送无状态重置的效果可能是一样的。

终端不能从短包头数据包中判断源连接ID；因此，它不能在无状态重置中设置目标连接ID。于是目标连接ID会和之前发送的数据包中使用的值不一样。随机的目标连接ID能使连接ID表现得像是迁移至由**新连接ID帧**提供的新连接ID的结果；详见[第19.15章](#19.15_NEW_CONNECTION_ID_Frames)。

使用随机的连接ID会有两个问题：

* 数据包可能无法抵达对端。如果目标连接ID在路由至对端时起关键作用，那么该数据包可能被错误地路由。作为响应，这可能会触发另一个无状态重置；详见[第10.3.3章](#10.3.3_Looping)。没有被正确路由的无状态重置使得错误检测和恢复机制失去效果。在这种情况下，终端需要依靠其他方法——比如计时器——来检测连接已失败。

* 随机生成的连接ID可以被不是对端的其他实体识别为可能的无状态重置。偶尔使用不同的连接ID的终端可以对此引入一些不确定性。

这样的无状态重置设计是特定于QUIC版本1的。支持多个QUIC版本的终端创建的无状态重置应该可以被支持所有当前终端所支持的版本（或所有在当前终端丢失状态前可能支持的版本）的对端接受。新QUIC版本的设计者应当注意上述这一点，并且要么(1)重用当前设计，要么(2)使用数据包除了最后16个字节之外的某个部分来携带数据。
