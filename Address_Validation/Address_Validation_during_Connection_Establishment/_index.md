---
title: "8.1 连接建立期间的地址验证"
anchor: "8.1_Address_Validation_during_Connection_Establishment"
weight: 810
rank: "h2"
---

连接建立为两侧终端隐式提供了地址验证。具体来说，接收到一个受握手密钥保护的数据包证实了对端已成功处理了初始数据包。一旦终端成功处理了来自对端的握手数据包，它就能将对端地址认定为已验证。

除此之外，如果对端使用了一个由终端选择的连接ID并且连接ID包含至少64位的熵，那么终端{{< req_level MAY >}}将对端地址认定为已验证。

对客户端来说，它的首个初始数据包中目标连接ID字段的值允许它有机会验证服务器的地址，只要服务器能成功处理任一数据包。来自服务器的初始数据包会受到从那个目标连接ID字段的值衍生的密钥的保护（详见《[QUIC-TLS](../RFC9001_Chinese_Translation)》的[第5.2章](../RFC9001_Chinese_Translation/#5.2_Initial_Secrets)）。另一方面，这个值会被服务器在版本协商包（详见[第6章](#6_Version_Negotiation)）中被回显，或在重试数据包的完整性标签中被使用（详见《[QUIC-TLS](../RFC9001_Chinese_Translation)》的[第5.8章](../RFC9001_Chinese_Translation/#5.8_Retry_Packet_Integrity)）。

在验证客户端地址前，服务器发送的字节数{{< req_level MUST_NOT >}}超过已接收字节数三倍。这就限制了所有能用伪造源地址的方式实施的放大攻击的量级。出于在地址验证前避免放大攻击的目的，服务器{{< req_level MUST >}}统计在数据报中接收的载荷的字节数，每个数据报都是归属于唯一的某条连接的。这里的数据报既包括了含有被成功处理的数据包的数据报，也包括了含有被全部丢弃的数据包的数据报。

客户端{{< req_level MUST >}}确保包含初始数据包的UDP数据报含有至少1200字节的UDP载荷，不够就加**填充帧**。发送扩充过的数据报的客户端允许服务器在完成地址验证前发送更多数据。

如果来自服务器的初始数据包或握手数据包遭遇丢包，并且客户端没有发送额外的初始数据包或握手数据包，那么这会引发死锁。当客户端已经接收到了所有它发出的数据的确认但服务器抵达了抗放大上限，那么死锁就会发生。在这种情况下，当客户端没有理由发送额外的数据包时，服务器将无法发送更多数据因为它还没有验证过客户端的地址。为了避免这种死锁，客户端{{< req_level MUST >}}在一个探测包超时（PTO）的时候发送一个数据包；详见《[QUIC恢复](../RFC9002_Chinese_Translation)》的[第6.2章](../RFC9002_Chinese_Translation/#6.2_Probe_Timeout)。具体来说，如果客户端没有握手密钥，那么它{{< req_level MUST >}}用包含至少1200字节的UDP数据报发送一个初始数据包，否则发送的是握手数据包。

服务器可能想要在开始加密握手前验证客户端地址。QUIC使用一个包含在初始数据包的令牌以在完成握手前提供地址验证。这个令牌是在连接建立期间通过重试数据包（详见[第8.1.2章](#8.1.2_Address_Validation_Using_Retry_Packets)），或在之前的连接中通过**新令牌帧**（详见[第8.1.3章](#8.1.3_Address_Validation_for_Future_Connections)），分发给客户端的。

除了在地址验证通过前被施加发送限制之外，服务器还在能发送的内容上被拥塞控制器所设置的上限所限制。客户端则仅受拥塞控制器的限制。
