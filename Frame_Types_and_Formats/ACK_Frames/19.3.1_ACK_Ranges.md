---
title: "19.3.1 ACK块"
anchor: "19.3.1_ACK_Ranges"
weight: 190301
rank: "h3"
---

每个ACK块由交替的空档和ACK块长度值构成，按包号降序排列。
ACK块可以重复。
空档和ACK块长度值的数量由ACK块计数字段决定，每个ACK块中的一个值（空档或ACK块长度）对应ACK块计数字段的每个值。

ACK块的结构如[图26](#Figure_26_ACK_Ranges)所示。

{{% block_ref
indx="Figure_26_ACK_Ranges"
title="图26：ACK块" %}}

```
ACK块 {
  空档 (i),
  ACK块长度 (i),
}
```

{{% /block_ref %}}

构成ACK块的字段是：

空档（Gap）：

:   一个可变长度整型值，表示比前述ACK块中的最小数据包号小一的数据包之前连续未被确认数据包的数目。


ACK块长度（ACK Range Length）：

:   一个可变长度整型值，表示先前空档确定的最大数据包号之前连续被确认数据包的数目。

空档和ACK块长度值使用一个相对整型编码以提高效率。
即使每个编码结果是正值，但也会被减去，因此每个ACK块表示的都是包号逐渐递减的数据包。

每个ACK块确认一段包号连续的数据包，通过ACK块内包号最大的被确认数据包之前的包数指定确认范围。
值为0表示只有包号最大的数据包被确认。
更大的ACK块值表示更大的确认范围，与此同时该块内最小数据包号则更小。
换言之，给定ACK块最大数据包号，则最小数据包号通过下述公式计算：

```
最小数据包号 = 最大数据包号 - ACK块值
```

一个ACK块确认最小数据包号到最大数据包号之间的全部数据包，包含两端。

一个ACK块的最大数据包号通过累积减去先前的所有ACK块长度和空档确定。

每个空档表示一段未被确认的数据包。
空档内未被确认的数据包数目比空档字段中的编码值多1。

空档字段值使用以下公式为后续ACK块生成最大的数据包号值：

```
最大数据包号 = 先前最小数据包号 - 空档值 - 2
```

如果任何有关计算得到的数据包号是负数，则终端{{< req_level MUST >}}产生一个`FRAME_ENCODING_ERROR`类型的连接错误。
