---
title: "17.1 数据包号编码与解码"
anchor: "17.1_Packet_Number_Encoding_and_Decoding"
weight: 1710
rank: "h2"
---

数据包号是范围在`0`至<code>2<sup>62</sup>-1</code>中的整数（[第12.3章](#12.3_Packet_Numbers)）。当在长包或短包的头部出现时 ，它们被编码在1至4字节中。通过仅使用数据包号的几个最低有效位，用于表示数据包号的比特位数量得以被减少。

经过编码的数据包号是受保护的，如《[QUIC-TLS](../RFC9001_Chinese_Translation)》[第5.4章](../RFC9001_Chinese_Translation/#5.4_Header_Protection)所述。

在接收到对于某数据包号空间的确认前，{{< req_level MUST >}}使用完整的数据包号；它不可以如下文所述那样被截断。

在接收到对于某数据包号空间的确认后，发送方{{< req_level MUST >}}使用一个足够大的数据包号尺寸，这个尺寸能够表示的范围大小至少是最大已确认数据包号和正在发送的数据包号之差的两倍。接收到该数据包的对端将正确解码数据包号，除非此包在传输过程中被延误得比很多更大编号的数据包更晚才被接收到。终端{{< req_level SHOULD >}}使用一个足够大的数据包号编码，使得即便此数据包比后续发送的数据包更晚到达，其数据包号也能被恢复。

于是，某数据包号编码的尺寸至少要比连续未被确认的数据包号的数量（包括此数据包本身）的以`2`为底的对数值大`1`比特。在[附录A.2](#A.2_Sample_Packet_Number_Encoding_Algorithm)中可以找到数据包号编码的伪代码和一个样例。

在接收方一侧，数据包号的保护在恢复完整数据包号前被移除。完整的数据包号随后被重建，重建基于数据包中出现的包号有效比特位的数量和值，以及已接收的且成功认证的数据包中最大的数据包号。恢复完整的数据包号对于成功移除数据包保护很有必要。

一旦头部保护被移除，通过找到与下一个预期数据包更接近的数据包号值即可将数据包号解码。下一个预期数据包就是将最大的已接收数据包编号加上`1`。在[附录A.3](#A.3_Sample_Packet_Number_Decoding_Algorithm)中可以找到数据包号解码的伪代码和一个样例。
