---
title: "13.2.1 发送ACK帧"
anchor: "13.2.1_Sending_ACK_Frames"
weight: 1321
rank: "h3"
---

所有数据包都{{< req_level SHOULD >}}被确认至少一次，ACK触发包{{< req_level MUST >}}在终端使用传输参数`max_ack_delay`（最大ACK延迟）沟通的最大延迟时间内被确认至少一次，详见[第18.2章](#18.2_Transport_Parameter_Definitions)。`max_ack_delay `声明了一个显式的约定：终端承诺不会故意拖延**ACK触发包**的确认以致延迟时间超过那个约定值。如果它这么做了，那么超出量会积累到RTT预估值上，并且导致来自对端的无效的或延迟的重传。发送方使用接收方的`max_ack_delay`值来决定基于计时器的重传的超时时间，详见《[QUIC恢复](../RFC9002_Chinese_Translation)》的[第6.2章](../RFC9002_Chinese_Translation/#6.2_Probe_Timeout)。

除了以下例外，终端{{< req_level MUST >}}立即确认所有引发确认的初始数据包和握手数据包，并且在它宣告的`max_ack_delay`之内确认所有引发确认的0-RTT数据包和1-RTT数据包。终端如果在握手确认前就收到了握手数据包、0-RTT数据包和1-RTT数据包，那么它可能还没有用来解密这些数据包的数据包保护密钥。因此它可以缓存这些数据包，等得到了必要的密钥再确认它们。

由于仅包含**ACK帧**的数据包不受拥塞控制，终端在响应一个ACK触发包时，{{< req_level MUST_NOT >}}发送超过一个这样的数据包。

终端在响应非ACK触发包时，{{< req_level MUST_NOT >}}发送非ACK触发包，即便在接收到的数据包前存在数据包空档。这避免了用确认响应确认的无限循环，避免连接无法进入闲置状态。非ACK触发包最终会在终端响应其他事件而发送的**ACK帧**中被确认。

一味发送**ACK帧**的终端不会从对端收到确认，除非这些帧和ACK触发帧一起被包含在数据包中。当有新的ACK触发包要确认时，终端{{< req_level SHOULD >}}将这些**ACK帧**一块发送。当只有非ACK触发包要确认时，终端{{< req_level MAY >}}选择等接收到一个ACK触发包时再将这些**ACK帧**一块发送。

只发送非ACK触发包的终端可以选择偶尔添加一个ACK触发帧到这些数据包中以确保它能收到确认，详见[第13.2.4章](#13.2.4_Limiting_Ranges_by_Tracking_ACK_Frames)。在那种情况下，终端{{< req_level MUST_NOT >}}在所有本来不引发确认的数据包中都添加ACK触发帧，以避免用确认响应确认的无限循环。

为了辅助发送方的丢包检测，在以下情况中若收到一个ACK触发包，终端{{< req_level SHOULD >}}立即生成并发送**ACK帧**：

* 当接收到的数据包的数据包号小于另一个已经被接收到的ACK触发包的时；

* 当接收到的数据包的数据包号大于已接收到的ACK触发包的数据包号最大值，且在它们之间有缺失的数据包时。

类似地，标记了IP头部的ECN拥塞预警（CE）码点的数据包{{< req_level SHOULD >}}被立即确认，以减少对端对拥塞事件的响应时间。

对没有遵守以上指导的接收方，《[QUIC恢复](../RFC9002_Chinese_Translation)》中的算法应当是能适应的。即使如此，QUIC实现也应该在谨慎地考虑任何变更会对性能的影响之后，再违背这些要求，既要考虑对终端建立的连接的性能影响，也要考虑对网络中其他用户的性能影响。
