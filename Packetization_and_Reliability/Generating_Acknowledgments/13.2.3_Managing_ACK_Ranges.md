---
title: "13.2.3 管理ACK块"
anchor: "13.2.3_Managing_ACK_Ranges"
weight: 1323
rank: "h3"
---

被发送的**ACK帧**中包含一个或多个已确认数据包的块。包含对更早期的数据包的确认减少了因之前发送的**ACK帧**丢包而引起无效重传的可能性，代价是**ACK帧**会变得更大。

**ACK帧**{{< req_level SHOULD >}}始终确认最近接收到的数据包，同时接收到的数据包越是乱序，尽快发送更新后的**ACK帧**就越是重要，以避免对端将某个数据包认定为丢包而对其中包含的帧进行无效的重传。一个**ACK帧**应当能被放进单个QUIC数据包中。如果不能，那么更早期的块（有着最小的数据包号的那些）会被省略。

接收方限制它记录的ACK块（详见[第19.3.1章](#19.3.1_ACK_Ranges)）的数量和在**ACK帧**中发送的ACK块的数量，这既是为了限制ACK帧的尺寸也是为了避免耗尽资源。在接收到对一个**ACK帧**的确认后，接收方{{< req_level SHOULD >}}停止追踪那些在帧中被确认的ACK块。发送方可以期待绝大多数数据包都被确认，但是QUIC不保证接收方处理的所有数据包的确认都被对端接收到。

因保留了许多ACK块而使得**ACK帧**变得过大是有可能的。接收方可以丢弃未被确认的ACK块以限制**ACK帧**的尺寸，代价是来自发送方的更多重传。如果一个ACK帧大到放不进一个数据包中，那么就有必要这么做。接收方还{{< req_level MAY >}}进一步限制**ACK帧**的尺寸来为其他帧腾出空间，或为了限制确认所消耗的数据包容量。

除非接收方能确信它后续接收到的数据包号不会落在某个ACK块中，否则它{{< req_level MUST >}}保留那个块。使用最少的状态来做到这一点的方法之一是维护一个最小的数据包号，它会随着块被丢弃而增大。

接收方可以丢弃所有ACK块，但是{{< req_level MUST >}}保留最大的已被成功处理的数据包号，因为它被用于从后续数据包中恢复数据包号，详见[第17.1章](#17.1_Packet_Number_Encoding_and_Decoding)。

接收方{{< req_level SHOULD >}}在所有**ACK帧**中包含最大的已接收到的数据包号。这个最大确认数字段被用于在发送方一侧进行的ECN验证，使用一个比先前发送的**ACK帧**中的更小的值会造成ECN被不必要地禁用，详见[第13.4.2章](#13.4.2_ECN_Validation)。

[第13.2.4章](#13.2.4_Limiting_Ranges_by_Tracking_ACK_Frames)描述了一个如何决定在各个**ACK帧**中分别确认哪些数据包的示例方法。尽管这个算法的目标是为每个已处理的数据包生成一个确认，但是确认依旧有可能遭遇丢包。
